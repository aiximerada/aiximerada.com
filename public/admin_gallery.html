// 1. 批量下載原圖 (優化版：並行處理)
        window.batchDownloadOriginal = async function() {
            if(selectedItems.size === 0) return alert('請先選取圖片');
            
            showProgress(true, `準備並行下載 ${selectedItems.size} 張原圖...`);
            
            const items = Array.from(selectedItems);
            // ⚡ 並行觸發
            const downloadPromises = items.map(async (docId, index) => {
                const data = allDocsData[docId];
                // 為了避免瀏覽器一次擋掉太多彈窗，我們加入微小的隨機延遲
                await new Promise(r => setTimeout(r, index * 300)); 
                updateProgress(`下載請求: ${data.fileName}`);
                await triggerDownload(data.imageUrl, data.fileName);
            });

            await Promise.all(downloadPromises);
            showProgress(false);
        }

        // 2. 批量壓縮下載 (優化版：並行運算)
        window.batchCompressAndDownload = async function() {
            if(selectedItems.size === 0) return alert('請先選取圖片');
            
            const qualityVal = document.getElementById('globalQuality').value;
            const quality = qualityVal / 100;

            showProgress(true, `正在並行壓縮處理...`);

            const items = Array.from(selectedItems);
            
            // ⚡ 並行壓縮
            // 這裡我們限制並發數為 3，避免把瀏覽器記憶體撐爆
            const concurrencyLimit = 3;
            const chunks = [];
            for (let i = 0; i < items.length; i += concurrencyLimit) {
                chunks.push(items.slice(i, i + concurrencyLimit));
            }

            for (const chunk of chunks) {
                const promises = chunk.map(async (docId) => {
                    const data = allDocsData[docId];
                    const mask = document.getElementById(`mask-img-${docId}`);
                    if(mask) mask.style.display = 'flex';
                    
                    try {
                        await processAndDownload(data.imageUrl, data.fileName, quality);
                    } catch(e) { console.error(e); }
                    
                    if(mask) mask.style.display = 'none';
                });
                await Promise.all(promises);
                updateProgress(`已處理一組... 剩餘任務`);
            }
            
            showProgress(false);
        }