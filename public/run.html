<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ¥µé€Ÿé€ƒäº¡ - ç”Ÿå­˜æŒ‘æˆ°</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-red: #ff3131;
            --bg-dark: #050510;
        }
        body {
            margin: 0; padding: 0;
            background-color: var(--bg-dark);
            color: #fff;
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif;
            overflow: hidden;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh;
            user-select: none;
            touch-action: none; /* ç¦æ­¢è§¸æ§ç¸®æ”¾ */
        }

        /* --- èƒŒæ™¯ç¶²æ ¼ç‰¹æ•ˆ --- */
        .grid-bg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: 
                linear-gradient(rgba(0, 243, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.1) 1px, transparent 1px);
            background-size: 40px 40px;
            transform: perspective(500px) rotateX(60deg);
            transform-origin: center 100%;
            animation: gridMove 0.5s linear infinite; /* èƒŒæ™¯åŠ é€Ÿï¼Œå¢åŠ é€Ÿåº¦æ„Ÿ */
            z-index: -1;
            opacity: 0.3;
        }
        @keyframes gridMove { from { background-position: 0 0; } to { background-position: 0 40px; } }

        /* --- UI ä»‹é¢ --- */
        .ui-layer {
            position: absolute; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }
        .header { display: flex; justify-content: space-between; align-items: flex-start; pointer-events: auto;}
        .back-btn { 
            color: var(--neon-blue); text-decoration: none; border: 1px solid var(--neon-blue); 
            padding: 8px 20px; border-radius: 20px; background: rgba(0,0,0,0.5); 
            display: flex; align-items: center; gap: 8px; transition: 0.3s;
            box-shadow: 0 0 10px var(--neon-blue);
        }
        .back-btn:hover { background: var(--neon-blue); color: #000; }
        
        .score-info { text-align: right; text-shadow: 0 0 10px var(--neon-blue); }
        .score-display { font-size: 1.8rem; font-weight: bold; color: #fff; }
        .high-score { font-size: 1rem; color: #aaa; }

        /* --- éŠæˆ²ç•«å¸ƒ --- */
        #gameCanvas {
            border-bottom: 2px solid var(--neon-blue);
            background: linear-gradient(to bottom, transparent, rgba(0, 243, 255, 0.05));
            box-shadow: 0 10px 50px rgba(0, 243, 255, 0.1);
        }

        /* --- é¸å–®å±¤ --- */
        .menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 16, 0.9);
            backdrop-filter: blur(8px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 10; pointer-events: auto;
            transition: 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; }
        
        h1 { font-size: 3.5rem; margin: 0 0 5px; color: #fff; text-shadow: 2px 2px 0px var(--neon-pink), -2px -2px 0px var(--neon-blue); letter-spacing: 5px; font-weight: 900; font-style: italic;}
        .subtitle { color: var(--neon-blue); letter-spacing: 5px; margin-bottom: 20px; font-size: 1.2rem; }
        
        .input-group { margin: 15px 0; text-align: center; }
        input { 
            background: rgba(0,0,0,0.5); border: 2px solid var(--neon-blue); color: #fff; 
            padding: 10px 20px; border-radius: 30px; font-size: 1.2rem; text-align: center; outline: none; width: 250px;
        }
        input:focus { box-shadow: 0 0 15px var(--neon-blue); }

        .btn {
            background: var(--neon-blue); color: #000; border: none; padding: 12px 40px;
            font-size: 1.5rem; border-radius: 50px; cursor: pointer; font-weight: bold;
            box-shadow: 0 0 20px var(--neon-blue); transition: 0.2s; margin-top: 10px;
        }
        .btn:hover { transform: scale(1.05); background: #fff; }
        .btn:active { transform: scale(0.95); }

        /* --- æ’è¡Œæ¦œ --- */
        .leaderboard {
            width: 320px; max-height: 250px; overflow-y: auto;
            margin-top: 25px; border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px; background: rgba(0,0,0,0.6); padding: 15px;
        }
        .lb-title { text-align: center; color: var(--neon-blue); font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; }
        .lb-item { display: flex; justify-content: space-between; padding: 6px 10px; border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 1rem; }
        .lb-item:nth-child(2) { color: #ffd700; font-weight: bold; }
        .lb-item:nth-child(3) { color: #c0c0c0; }
        .lb-item:nth-child(4) { color: #cd7f32; }
        .lb-name { max-width: 160px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        .mobile-hint { position: absolute; bottom: 50px; color: rgba(255,255,255,0.5); font-size: 0.9rem; animation: blink 2s infinite; }
        @keyframes blink { 50% { opacity: 0.3; } }
    </style>
</head>
<body>

    <div class="grid-bg"></div>

    <div class="ui-layer">
        <div class="header">
            <a href="entertainment.html" class="back-btn"><i class="fa-solid fa-arrow-left"></i> å¨›æ¨‚å€</a>
            <div class="score-info">
                <div class="score-display">å¾—åˆ†: <span id="currentScore">0</span></div>
                <div class="high-score">æœ€é«˜ç´€éŒ„: <span id="localBest">0</span></div>
            </div>
        </div>
        <div class="mobile-hint">é»æ“Šç•«é¢ / æŒ‰ç©ºç™½éµ è·³èº</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="menuOverlay" class="menu-overlay">
        <h1>æ¥µé€Ÿé€ƒäº¡</h1>
        <div class="subtitle">SPEED ESCAPE</div>
        
        <div class="input-group">
            <input type="text" id="playerName" placeholder="è¼¸å…¥æš±ç¨± (å¯ä¸­æ–‡)" maxlength="10">
        </div>
        
        <button class="btn" id="startBtn">é–‹å§‹éŠæˆ²</button>

        <div class="leaderboard" id="leaderboardList">
            <div class="lb-title"><i class="fa-solid fa-trophy"></i> ä¸–ç•Œæ’è¡Œæ¦œ</div>
            <div style="text-align:center; color:#aaa; margin-top:10px;">è®€å–ä¸­...</div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

        // Firebase Config (è‡ªå‹•æ³¨å…¥)
        const firebaseConfig = {
            // Hosting ç’°å¢ƒæœƒè‡ªå‹•å¡«å…¥ï¼Œæœ¬åœ°æ¸¬è©¦è‹¥éœ€è¦æ’è¡Œæ¦œè«‹å¡«å…¥æ‚¨çš„ Config
        };
        
        let db;
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
        } catch (e) {
            fetch('/__/firebase/init.json').then(async response => {
                const config = await response.json();
                const app = initializeApp(config);
                db = getFirestore(app);
                loadLeaderboard();
            }).catch(err => console.log("Local Dev Mode: Leaderboard may not work without config"));
        }

        // --- æ ¸å¿ƒè®Šæ•¸ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        
        // ğŸ”¥ ç‰©ç†æ‰‹æ„Ÿèª¿æ ¡ (é‡é»ä¿®æ”¹å€) ğŸ”¥
        let score = 0;
        let gameSpeed = 5;      // åˆå§‹é€Ÿåº¦
        let isGameOver = false;
        let isPlaying = false;
        let animationId;
        let isJumpPressed = false;
        
        const GRAVITY = 0.8;    // é‡åŠ› (åŸ 0.5 -> 0.8) è®“ä¸‹å¢œæ›´å¿«ï¼Œæ¸›å°‘æ»¯ç©ºæ„Ÿ
        const JUMP_FORCE = -14; // è·³èºåŠ› (åŸ -11 -> -14) é…åˆé‡åŠ›èª¿æ•´ï¼Œèµ·è·³æ›´ä¹¾è„†

        const badWords = ['fuck', 'shit', 'bitch', 'ass', 'å¹¹', 'é æ¯', 'é›æ°', 'ç™½ç—´', 'æ™ºéšœ', 'å‚»é€¼', 'æ­»', 'è³¤', 'ç‹å…«', 'è…¦æ®˜'];

        // --- éŸ³æ•ˆç³»çµ± ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'jump') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'crash') {
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(100, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.3);
            }
        }

        // --- éŠæˆ²ç‰©ä»¶ ---
        const player = {
            x: 50, y: 0, width: 40, height: 40,
            dy: 0, grounded: false, color: '#00f3ff',
            draw() {
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#fff'; // æ ¸å¿ƒäº®é»
                ctx.fillRect(this.x + 10, this.y + 10, 20, 20);
                ctx.shadowBlur = 0;
            },
            update() {
                this.dy += GRAVITY; // å¥—ç”¨æ–°é‡åŠ›
                this.y += this.dy;

                // åœ°é¢åˆ¤å®š
                if (this.y + this.height > height - 50) {
                    this.y = height - 50 - this.height;
                    this.dy = 0;
                    this.grounded = true;
                } else {
                    this.grounded = false;
                }
            },
            jump() {
                if (this.grounded) {
                    this.dy = JUMP_FORCE; // å¥—ç”¨æ–°è·³èºåŠ›
                    this.grounded = false;
                    playSound('jump');
                    createParticles(this.x + this.width/2, this.y + this.height, 'jump');
                }
            }
        };

        class Obstacle {
            constructor() {
                this.width = 30 + Math.random() * 30;
                this.height = 40 + Math.random() * 40;
                this.x = width;
                this.y = height - 50 - this.height;
                this.marked = false;
            }
            draw() {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff3131';
                ctx.fillStyle = '#ff3131';
                // ç•«å‡ºå¸¶æ–œè§’çš„éšœç¤™ç‰©
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.width, this.y);
                ctx.lineTo(this.x + this.width + 10, this.y - 10);
                ctx.lineTo(this.x + 10, this.y - 10);
                ctx.fill();
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.shadowBlur = 0;
            }
            update() {
                this.x -= gameSpeed;
            }
        }

        let particles = [];
        class Particle {
            constructor(x, y, type) {
                this.x = x; this.y = y;
                this.size = Math.random() * 4 + 2;
                this.speedX = Math.random() * 6 - 3; 
                this.speedY = Math.random() * 6 - 3;
                this.life = 1;
                this.type = type;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.life -= 0.04; // ç²’å­æ¶ˆå¤±é€Ÿåº¦
            }
            draw() {
                if(this.life <= 0) return;
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.type === 'jump' ? '#00f3ff' : '#ffaa00';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        function createParticles(x, y, type) {
            const count = type === 'crash' ? 25 : 8; 
            for(let i=0; i<count; i++) {
                particles.push(new Particle(x, y, type));
            }
        }

        let obstacles = [];

        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            const savedBest = localStorage.getItem('speedEscapeBest') || 0;
            document.getElementById('localBest').innerText = savedBest;
        }

        function resetGame() {
            player.y = height - 150;
            player.dy = 0;
            obstacles = [];
            particles = [];
            score = 0;
            gameSpeed = 5; // é‡ç½®é€Ÿåº¦
            isGameOver = false;
            isPlaying = true;
            document.getElementById('menuOverlay').classList.add('hidden');
            lastObstacleTime = 0;
            animate();
        }

        let lastObstacleTime = 0;

        function animate(timestamp) {
            if (!isPlaying) return;
            ctx.clearRect(0, 0, width, height);

            // åœ°é¢ç·š
            ctx.strokeStyle = '#00f3ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, height - 50);
            ctx.lineTo(width, height - 50);
            ctx.stroke();

            player.update();
            player.draw();

            // ç”Ÿæˆéšœç¤™ç‰©
            if (!lastObstacleTime) lastObstacleTime = timestamp;
            const deltaTime = timestamp - lastObstacleTime;
            
            // éš¨æ©Ÿé–“éš” (1.2ç§’ ~ 2ç§’)
            if (Math.random() < 0.02 && deltaTime > 1200) { 
                obstacles.push(new Obstacle());
                lastObstacleTime = timestamp;
            }

            // æ›´æ–°éšœç¤™ç‰©
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let ob = obstacles[i];
                ob.update();
                ob.draw();

                // ğŸ”¥ ç¢°æ’å„ªåŒ–ï¼šåˆ¤å®šç¯„åœå…§ç¸® 10pxï¼Œé¿å…ç©ºæ°£æ’ç‰† ğŸ”¥
                if (
                    player.x < ob.x + ob.width - 10 &&
                    player.x + player.width > ob.x + 10 &&
                    player.y < ob.y + ob.height - 10 &&
                    player.y + player.height > ob.y + 10
                ) {
                    gameOver();
                    return; // ç«‹å³åœæ­¢æ¸²æŸ“ï¼Œé¿å…ç•«é¢ç©¿å¹«
                }

                // è¨ˆåˆ†
                if (ob.x + ob.width < player.x && !ob.marked) {
                    score += 10;
                    ob.marked = true;
                    document.getElementById('currentScore').innerText = score;
                    // åŠ é€Ÿä¸Šé™æ§åˆ¶
                    if(score % 100 === 0 && gameSpeed < 10) gameSpeed += 0.4;
                }

                // ç§»é™¤
                if (ob.x + ob.width < 0) {
                    obstacles.splice(i, 1);
                }
            }

            // æ›´æ–°ç²’å­
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.update();
                p.draw();
                if(p.life <= 0) particles.splice(i, 1);
            }

            // è‡ªç„¶æ™‚é–“åŠ åˆ†
            if(Math.floor(timestamp / 100) % 5 === 0 && timestamp % 10 === 0) {
               score++;
               document.getElementById('currentScore').innerText = score;
            }

            animationId = requestAnimationFrame(animate);
        }

        function gameOver() {
            isPlaying = false;
            cancelAnimationFrame(animationId);
            playSound('crash');
            createParticles(player.x + 20, player.y + 20, 'crash');
            
            // ç¹ªè£½å®šæ ¼ç•«é¢
            particles.forEach(p => p.draw());

            const currentBest = parseInt(localStorage.getItem('speedEscapeBest') || 0);
            if(score > currentBest) {
                localStorage.setItem('speedEscapeBest', score);
                document.getElementById('localBest').innerText = score;
            }

            // ä¸Šå‚³åˆ†æ•¸
            handleUploadScore();

            setTimeout(() => {
                document.getElementById('menuOverlay').classList.remove('hidden');
                document.querySelector('#menuOverlay h1').innerText = "ç”Ÿå­˜çµæŸ";
                document.getElementById('startBtn').innerText = "å†ä¾†ä¸€å±€";
            }, 1000);
        }

        // --- æ’è¡Œæ¦œ ---
        function cleanName(name) {
            let clean = name.toLowerCase();
            for (let word of badWords) {
                if (clean.includes(word)) return false;
            }
            return true;
        }

        async function handleUploadScore() {
            // ğŸ”¥ å–æ¶ˆ 50 åˆ†é™åˆ¶ï¼Œ1 åˆ†ä¹Ÿä¸Šå‚³æ–¹ä¾¿æ¸¬è©¦ ğŸ”¥
            if(!db || score <= 0) return;
            
            const nameInput = document.getElementById('playerName');
            let name = nameInput.value.trim() || 'åŒ¿åç©å®¶';
            if(!cleanName(name)) name = 'åŒ¿åç©å®¶';

            try {
                await addDoc(collection(db, "leaderboard"), {
                    name: name,
                    score: score,
                    timestamp: new Date()
                });
                console.log("ä¸Šå‚³æˆåŠŸ");
                loadLeaderboard(); // ä¸Šå‚³å¾Œç«‹å³åˆ·æ–°
            } catch (e) { console.error("ä¸Šå‚³å¤±æ•—", e); }
        }

        async function loadLeaderboard() {
            if(!db) return;
            const list = document.getElementById('leaderboardList');
            const titleHtml = '<div class="lb-title"><i class="fa-solid fa-trophy"></i> ä¸–ç•Œæ’è¡Œæ¦œ</div>';
            list.innerHTML = titleHtml + '<div style="text-align:center;">è®€å–ä¸­...</div>';

            try {
                const q = query(collection(db, "leaderboard"), orderBy("score", "desc"), limit(10));
                const querySnapshot = await getDocs(q);
                let html = titleHtml;
                let rank = 1;
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    html += `
                        <div class="lb-item">
                            <span>#${rank} <span class="lb-name">${data.name}</span></span>
                            <span>${data.score}</span>
                        </div>`;
                    rank++;
                });
                if(html === titleHtml) html += '<div style="text-align:center; color:#aaa; margin-top:10px;">å°šç„¡ç´€éŒ„</div>';
                list.innerHTML = html;
            } catch (e) {
                console.error(e);
                list.innerHTML = titleHtml + '<div style="text-align:center; color:#aaa;">è®€å–å¤±æ•—</div>';
            }
        }

        // --- äº‹ä»¶ ---
        window.addEventListener('resize', init);
        
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                if(isPlaying && !isJumpPressed) {
                    player.jump();
                    isJumpPressed = true;
                }
            }
        });
        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space') isJumpPressed = false;
        });

        window.addEventListener('touchstart', (e) => {
            if(isPlaying) player.jump();
            e.preventDefault();
        }, {passive: false});

        document.getElementById('startBtn').addEventListener('click', () => {
            const name = document.getElementById('playerName').value;
            if(name && !cleanName(name)) { alert("æš±ç¨±åŒ…å«ä¸é›…å­—çœ¼"); return; }
            resetGame();
        });

        init();
        if(db) loadLeaderboard();

    </script>
</body>
</html>