<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ˜Ÿéš›å·¡èˆªï¼šé«˜å£“çªåœ - ç‰éœ²å¯¶åº«</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg-dark: #050510;
            --neon-cyan: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff9d;
            --star-gold: #f2c94c;
        }
        body {
            margin: 0; padding: 0; background-color: var(--bg-dark); color: #fff;
            font-family: 'Microsoft JhengHei', sans-serif;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; overflow: hidden; user-select: none; touch-action: none;
        }

        /* --- âœ¨ è¦–å·®æ˜Ÿç©ºèƒŒæ™¯ --- */
        .stars-1 { position: fixed; top: 0; left: 0; width: 200%; height: 100%; background: radial-gradient(1px 1px at 25px 35px, #fff, transparent); background-size: 150px 150px; animation: spaceMove 40s linear infinite; z-index: -3; opacity: 0.4; }
        .stars-2 { position: fixed; top: 0; left: 0; width: 200%; height: 100%; background: radial-gradient(2px 2px at 50px 80px, var(--neon-cyan), transparent); background-size: 250px 250px; animation: spaceMove 20s linear infinite; z-index: -2; opacity: 0.3; }
        @keyframes spaceMove { from { transform: translateX(0); } to { transform: translateX(-50%); } }

        /* --- HUDå„€è¡¨æ¿ --- */
        .hud {
            position: absolute; top: 20px; width: 90%; max-width: 800px;
            display: flex; justify-content: space-between; align-items: center; z-index: 10;
        }
        .score-box { font-family: 'Courier New', monospace; font-size: 1.5rem; font-weight: bold; }
        .best-label { font-size: 1rem; color: var(--star-gold); margin-right: 20px; }

        canvas { display: block; background: linear-gradient(to bottom, rgba(5,5,16,0) 60%, rgba(0, 243, 255, 0.08) 100%); border-bottom: 3px solid var(--neon-cyan); cursor: pointer; }

        /* --- å½ˆçª—ä»‹é¢ --- */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 16, 0.85); backdrop-filter: blur(12px);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100;
            transition: 0.3s; opacity: 0; pointer-events: none;
        }
        .overlay.show { opacity: 1; pointer-events: auto; }

        .result-card {
            background: linear-gradient(135deg, rgba(26, 44, 78, 0.9) 0%, rgba(11, 16, 33, 0.95) 100%);
            border: 2px solid var(--neon-cyan); padding: 40px; border-radius: 30px; text-align: center;
            width: 85%; max-width: 420px; box-shadow: 0 0 50px rgba(0, 243, 255, 0.2);
        }
        .rank-badge { display: inline-block; padding: 6px 25px; background: var(--neon-pink); border-radius: 20px; font-weight: bold; margin-bottom: 15px; box-shadow: 0 0 15px var(--neon-pink); font-size: 1.1rem; }
        .final-time { font-size: 4rem; font-weight: 900; margin: 10px 0; font-family: 'Courier New', monospace; color: #fff; text-shadow: 0 0 20px var(--neon-cyan); }
        
        .btn-group { display: flex; flex-direction: column; gap: 15px; margin-top: 25px; width: 100%; }
        .btn {
            background: var(--neon-cyan); color: #0b1021; border: none; padding: 16px 0; border-radius: 50px;
            font-size: 1.2rem; font-weight: 900; cursor: pointer; transition: 0.2s; text-decoration: none; text-align: center;
        }
        .btn:hover { background: #fff; transform: translateY(-2px); }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.2); }
    </style>
</head>
<body>
    <div class="stars-1"></div>
    <div class="stars-2"></div>

    <div class="hud">
        <div class="score-box">
            <span class="best-label">BEST: <span id="best-val">0.00s</span></span>
            TIME: <span id="score-val">0.00s</span>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="overlay" class="overlay show">
        <div class="result-card" id="start-card">
            <h1 style="color:var(--neon-cyan); font-size: 2.2rem; margin-bottom: 10px;">æ˜Ÿéš›å·¡èˆª</h1>
            <p style="color:#aaa; letter-spacing: 2px; margin-bottom: 30px;">HIGH-PRESSURE MODE</p>
            <div class="btn-group">
                <button class="btn" onclick="initGame()">å•Ÿå‹•å¼•æ“</button>
                <a href="entertainment.html" class="btn btn-secondary">è¿”å›åŸºåœ°</a>
            </div>
        </div>
        <div class="result-card" id="end-card" style="display:none;">
            <div id="rank-badge" class="rank-badge">ç¨±è™Ÿ</div>
            <div style="color:#aaa; font-size: 0.9rem;">ä»»å‹™å­˜æ´»æ™‚é–“</div>
            <div class="final-time" id="final-time">0.00s</div>
            <div class="btn-group">
                <button class="btn" onclick="initGame()">å†æ¬¡å‡ºæ“Š</button>
                <a href="entertainment.html" class="btn btn-secondary">è¿”å›åŸºåœ°</a>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreVal = document.getElementById('score-val');
        const bestVal = document.getElementById('best-val');
        const overlay = document.getElementById('overlay');
        const startCard = document.getElementById('start-card');
        const endCard = document.getElementById('end-card');
        const rankBadge = document.getElementById('rank-badge');

        let gameWidth, gameHeight;
        let isPlaying = false;
        let startTime;
        let currentTime = 0;
        let bestTime = parseFloat(localStorage.getItem('starship_best_time') || 0);
        bestVal.innerText = bestTime.toFixed(2) + "s";

        // --- ğŸ”¥ é›£åº¦å¹³è¡¡åƒæ•¸ (å·²ä¸Šèª¿) ğŸ”¥ ---
        const INITIAL_SPEED = 10;    // åˆå§‹é€Ÿåº¦å¾ 7 -> 10
        const MAX_SPEED = 18;        // æœ€å¤§é€Ÿåº¦ä¸Šé™èª¿é«˜
        const INITIAL_SPAWN_RATE = 80; // ç”Ÿæˆé–“éš”å¾ 120 -> 80 (è®Šå¿«)
        const MIN_SPAWN_RATE = 35;   // æœ€å¿«é–“éš”ç¸®çŸ­
        
        let gameSpeed = INITIAL_SPEED;
        const GRAVITY = 0.8;         // ä¸‹å¢œç¨å¾®åŠ å¿«ï¼Œæ›´ä¿è½
        const JUMP_STRENGTH = -14;   // è·³èºåŠ›é…åˆé‡åŠ›èª¿æ•´
        const GROUND_Y = 50;

        const starColors = ['#00f3ff', '#ff00ff', '#f2c94c', '#00ff9d'];

        let player = {
            x: 60, y: 0, width: 60, height: 30, dy: 0,
            draw() {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(Math.min(Math.max(this.dy * 0.03, -0.3), 0.3));
                ctx.translate(-(this.x + this.width/2), -(this.y + this.height/2));

                // å™´å°„ç«ç„°
                ctx.fillStyle = Math.random() > 0.5 ? '#00f3ff' : '#fff';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 10);
                ctx.lineTo(this.x - 25, this.y + 15);
                ctx.lineTo(this.x, this.y + 20);
                ctx.fill();

                // æˆ°æ©Ÿæ©Ÿèº«
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 15; ctx.shadowColor = '#00f3ff';
                ctx.beginPath();
                ctx.moveTo(this.x + this.width, this.y + 15); // é ­
                ctx.lineTo(this.x, this.y + 30); // åº•
                ctx.lineTo(this.x + 15, this.y + 15); // ä¸­
                ctx.lineTo(this.x, this.y); // é ‚
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
            },
            jump() { if(this.y >= gameHeight - GROUND_Y - this.height - 5) this.dy = JUMP_STRENGTH; }
        };

        let obstacles = [];
        let particles = [];
        let frameCount = 0;

        function resize() {
            gameWidth = canvas.width = window.innerWidth;
            gameHeight = canvas.height = Math.min(window.innerHeight * 0.7, 450);
            player.y = gameHeight - GROUND_Y - player.height;
        }

        function initGame() {
            obstacles = [];
            particles = [];
            gameSpeed = INITIAL_SPEED;
            frameCount = 0;
            currentTime = 0;
            startTime = Date.now();
            isPlaying = true;
            overlay.classList.remove('show');
            startCard.style.display = 'none';
            endCard.style.display = 'none';
            requestAnimationFrame(update);
        }

        function drawStar(cx, cy, spikes, outerRadius, innerRadius, color) {
            let rot = Math.PI / 2 * 3;
            let step = Math.PI / spikes;
            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                ctx.lineTo(cx + Math.cos(rot) * outerRadius, cy + Math.sin(rot) * outerRadius);
                rot += step;
                ctx.lineTo(cx + Math.cos(rot) * innerRadius, cy + Math.sin(rot) * innerRadius);
                rot += step;
            }
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.shadowBlur = 15; ctx.shadowColor = color;
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.size = Math.random() * 4 + 2;
                this.speedX = (Math.random() - 0.5) * 12;
                this.speedY = (Math.random() - 0.5) * 12;
                this.life = 1.0;
            }
            update() { this.x += this.speedX; this.y += this.speedY; this.life -= 0.02; }
            draw() {
                ctx.fillStyle = this.color; ctx.globalAlpha = this.life;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        function update() {
            ctx.clearRect(0, 0, gameWidth, gameHeight);
            
            // åœ°å¹³ç·š
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, gameHeight - GROUND_Y);
            ctx.lineTo(gameWidth, gameHeight - GROUND_Y);
            ctx.stroke();

            if(isPlaying) {
                currentTime = (Date.now() - startTime) / 1000;
                scoreVal.innerText = currentTime.toFixed(2) + "s";

                // å‹•é›£é›£åº¦è¨ˆç®—
                if (gameSpeed < MAX_SPEED) gameSpeed += 0.002;
                let currentSpawnRate = Math.max(MIN_SPAWN_RATE, INITIAL_SPAWN_RATE - Math.floor(currentTime * 2));

                player.dy += GRAVITY;
                player.y += player.dy;
                const groundLimit = gameHeight - GROUND_Y - player.height;
                if(player.y > groundLimit) { player.y = groundLimit; player.dy = 0; }
                player.draw();

                // ç”Ÿæˆéšœç¤™ç‰©
                if(frameCount % currentSpawnRate === 0) {
                    let size = Math.random() * 20 + 20;
                    obstacles.push({
                        x: gameWidth + size,
                        y: gameHeight - GROUND_Y - size - (Math.random() > 0.82 ? 75 : 0), 
                        size: size,
                        color: starColors[Math.floor(Math.random() * starColors.length)],
                        rotation: 0
                    });
                }

                for(let i = obstacles.length - 1; i >= 0; i--) {
                    let obs = obstacles[i];
                    obs.x -= gameSpeed;
                    obs.rotation += 0.06;
                    
                    ctx.save();
                    ctx.translate(obs.x, obs.y);
                    ctx.rotate(obs.rotation);
                    drawStar(0, 0, 5, obs.size, obs.size/2, obs.color);
                    ctx.restore();

                    // ç¢°æ’åˆ¤å®š
                    let dx = (player.x + player.width/2) - obs.x;
                    let dy = (player.y + player.height/2) - obs.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < obs.size * 0.7 + player.width/3) {
                        for(let k=0; k<40; k++) particles.push(new Particle(obs.x, obs.y, obs.color));
                        gameOver();
                    }
                    if(obs.x + obs.size < 0) obstacles.splice(i, 1);
                }
                frameCount++;
            } else {
                particles.forEach((p, idx) => {
                    p.update(); p.draw();
                    if(p.life <= 0) particles.splice(idx, 1);
                });
            }
            requestAnimationFrame(update);
        }

        function getRank(s) {
            if(s < 10) return { t: "æ˜Ÿéš›å¡µåŸƒ", c: "#aaa" };
            if(s < 25) return { t: "è¶…å…‰é€Ÿæ–°å…µ", c: "#fff" };
            if(s < 50) return { t: "æ™‚ç©ºè­·èˆªè€…", c: "#00ff9d" };
            if(s < 80) return { t: "çµæˆ¶åº§ç‹ç‰Œ", c: "#f2c94c" };
            return { t: "éŠ€æ²³å‚³å¥‡", c: "#bc13fe" };
        }

        function gameOver() {
            isPlaying = false;
            if(currentTime > bestTime) {
                bestTime = currentTime;
                localStorage.setItem('starship_best_time', bestTime);
                bestVal.innerText = bestTime.toFixed(2) + "s";
            }
            document.getElementById('final-time').innerText = currentTime.toFixed(2) + "s";
            const r = getRank(currentTime);
            rankBadge.innerText = r.t;
            rankBadge.style.background = r.c;
            rankBadge.style.boxShadow = `0 0 15px ${r.c}`;
            
            setTimeout(() => {
                overlay.classList.add('show');
                endCard.style.display = 'block';
            }, 800);
        }

        window.addEventListener('keydown', (e) => { if(e.code === 'Space') player.jump(); });
        window.addEventListener('touchstart', (e) => { e.preventDefault(); player.jump(); }, {passive: false});
        window.addEventListener('resize', resize);
        resize();
    </script>
</body>
</html>